"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[2597],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=u(n),h=l,k=m["".concat(s,".").concat(h)]||m[h]||p[h]||i;return n?a.createElement(k,o(o({ref:t},d),{},{components:n})):a.createElement(k,o({ref:t},d))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},49112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=n(87462),l=(n(67294),n(3905));const i={},o="Superfluid Staking",r={unversionedId:"modules/superfluid/README",id:"modules/superfluid/README",title:"Superfluid Staking",description:"Abstract",source:"@site/docs/osmosis-core/modules/superfluid/README.md",sourceDirName:"modules/superfluid",slug:"/modules/superfluid/",permalink:"/osmosis-core/modules/superfluid/",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/osmosis-core/modules/superfluid/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Osmosis modules",permalink:"/osmosis-core/modules/protorev/"},next:{title:"Token Factory",permalink:"/osmosis-core/modules/tokenfactory/"}},s={},u=[{value:"Abstract",id:"abstract",level:2},{value:"The process",id:"the-process",level:3},{value:"Example",id:"example",level:3},{value:"Why mint Osmo? How is this method safe and accurate?",id:"why-mint-osmo-how-is-this-method-safe-and-accurate",level:3},{value:"Bonding, unbonding, slashing",id:"bonding-unbonding-slashing",level:3},{value:"Bonding",id:"bonding",level:3},{value:"Unbonding",id:"unbonding",level:3},{value:"Concepts",id:"concepts",level:2},{value:"SyntheticLockups",id:"syntheticlockups",level:3},{value:"Intermediary Account",id:"intermediary-account",level:3},{value:"Intermediary Account Connection",id:"intermediary-account-connection",level:3},{value:"State",id:"state",level:2},{value:"Superfluid Asset",id:"superfluid-asset",level:3},{value:"Intermediary Accounts",id:"intermediary-accounts",level:3},{value:"Dedicated Gauges",id:"dedicated-gauges",level:3},{value:"Synthetic Lockups created",id:"synthetic-lockups-created",level:3},{value:"Osmo Equivalent Multipliers",id:"osmo-equivalent-multipliers",level:3},{value:"State changes",id:"state-changes",level:3},{value:"Superfluid Delegate",id:"superfluid-delegate",level:3},{value:"Superfluid Undelegate",id:"superfluid-undelegate",level:3},{value:"Lock and Superfluid Delegate",id:"lock-and-superfluid-delegate",level:3},{value:"Superfluid Unbond Lock",id:"superfluid-unbond-lock",level:3},{value:"Epochs",id:"epochs",level:2},{value:"Staking power updates",id:"staking-power-updates",level:2},{value:"How we handle it now",id:"how-we-handle-it-now",level:3},{value:"Other Module Hooks",id:"other-module-hooks",level:2},{value:"AfterEpochEnd",id:"afterepochend",level:3},{value:"AfterAddTokensToLock",id:"afteraddtokenstolock",level:3},{value:"BeforeValidatorSlashed",id:"beforevalidatorslashed",level:3},{value:"Proposal Hooks",id:"proposal-hooks",level:2},{value:"SetSuperfluidAssetsProposal",id:"setsuperfluidassetsproposal",level:3},{value:"RemoveSuperfluidAssetsProposal",id:"removesuperfluidassetsproposal",level:3},{value:"Events",id:"events",level:2},{value:"<code>types.TypeEvtSetSuperfluidAsset</code>",id:"typestypeevtsetsuperfluidasset",level:3},{value:"<code>types.TypeEvtRemoveSuperfluidAsset</code>",id:"typestypeevtremovesuperfluidasset",level:3},{value:"<code>types.TypeEvtSuperfluidDelegate</code>",id:"typestypeevtsuperfluiddelegate",level:3},{value:"<code>types.TypeEvtSuperfluidIncreaseDelegation</code>",id:"typestypeevtsuperfluidincreasedelegation",level:3},{value:"<code>types.TypeEvtSuperfluidUndelegate</code>",id:"typestypeevtsuperfluidundelegate",level:3},{value:"<code>types.TypeEvtSuperfluidUnbondLock</code>",id:"typestypeevtsuperfluidunbondlock",level:3},{value:"<code>types.TypeEvtUnpoolId</code>",id:"typestypeevtunpoolid",level:3},{value:"Messages",id:"messages-1",level:3},{value:"MsgSuperfluidDelegate",id:"msgsuperfluiddelegate",level:3},{value:"MsgSuperfluidUndelegate",id:"msgsuperfluidundelegate",level:3},{value:"MsgSuperfluidUnbondLock",id:"msgsuperfluidunbondlock",level:3},{value:"MsgLockAndSuperfluidDelegate",id:"msglockandsuperfluiddelegate",level:3},{value:"Proposals",id:"proposals",level:2},{value:"SetSuperfluidAssetsProposal",id:"setsuperfluidassetsproposal-1",level:3},{value:"RemoveSuperfluidAssetsProposal",id:"removesuperfluidassetsproposal-1",level:3},{value:"Queries",id:"queries",level:2},{value:"Params",id:"params",level:3},{value:"AssetType",id:"assettype",level:3},{value:"AllAssets",id:"allassets",level:3},{value:"AssetMultiplier",id:"assetmultiplier",level:3},{value:"ConnectedIntermediaryAccount",id:"connectedintermediaryaccount",level:3},{value:"AllIntermediaryAccounts",id:"allintermediaryaccounts",level:3},{value:"SuperfluidDelegationAmount",id:"superfluiddelegationamount",level:3},{value:"SuperfluidDelegationsByDelegator",id:"superfluiddelegationsbydelegator",level:3},{value:"SuperfluidDelegationsByValidatorDenom",id:"superfluiddelegationsbyvalidatordenom",level:3},{value:"EstimateSuperfluidDelegatedAmountByValidatorDenom",id:"estimatesuperfluiddelegatedamountbyvalidatordenom",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Slashing",id:"slashing",level:2},{value:"Nuances",id:"nuances",level:3},{value:"Correcting overslashing",id:"correcting-overslashing",level:3},{value:"Minting",id:"minting",level:2},{value:"Invariant",id:"invariant",level:3},{value:"Message Handlers",id:"message-handlers",level:2},{value:"SuperfluidDelegate",id:"superfluiddelegate",level:3},{value:"SuperfluidUndelegate",id:"superfluidundelegate",level:3},{value:"Superfluid Hooks",id:"superfluid-hooks",level:2},{value:"RefreshIntermediaryDelegationAmounts (AfterEpochEnd Hook)",id:"refreshintermediarydelegationamounts-afterepochend-hook",level:3},{value:"IncreaseSuperfluidDelegation (AfterAddTokensToLock Hook)",id:"increasesuperfluiddelegation-afteraddtokenstolock-hook",level:3},{value:"SlashLockupsForValidatorSlash (BeforeValidatorSlashed Hook)",id:"slashlockupsforvalidatorslash-beforevalidatorslashed-hook",level:3},{value:"See Also",id:"see-also",level:2},{value:"GetTotalSyntheticAssetsLocked",id:"gettotalsyntheticassetslocked",level:3}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"superfluid-staking"},"Superfluid Staking"),(0,l.kt)("h2",{id:"abstract"},"Abstract"),(0,l.kt)("p",null,'Superfluid Staking provides the consensus layer more security with a\nsort of "Proof of Useful Stake". Each person gets an amount of Osmo\nrepresentative of the value of their share of liquidity pool tokens\nstaked and delegated to validators, resulting in the security guarantee\nof the consensus layer to also be based on GAMM LP shares. The OSMO\ntoken is minted and burned in the context of Superfluid Staking.\nThroughout all of this, OSMO\'s supply is preserved in queries to the\nbank module.'),(0,l.kt)("h3",{id:"the-process"},"The process"),(0,l.kt)("p",null,"All of the below methods are found under the ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/tree/main/x/superfluid"},"Superfluid\nmodules"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"SuperfluidDelegate")," method stores your share of bonded\nliquidity pool tokens, with ",(0,l.kt)("inlineCode",{parentName:"li"},"validateLock")," as a verifier for lockup\ntime."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"GetSuperfluidOsmo")," mints OSMO tokens each day for delegation as a\nrepresentative of the value of your pool share. This amount is\nminted because the staking module at the moment requires staked\ntokens to be in OSMO. This amount is burned each day and re-minted\nto keep the representative amount of the value of your pool share\naccurate. The lockup duration is guaranteed from the underlying\nlockup module."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"GetExpectedDelegationAmount")," iterates over each (denom, delegate)\npair and checks for how much OSMO we have delegated. The difference\nfrom the current balance to what is expected is burned / minted to\nmatch with the expected."),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"messageServer")," method executes the Superfluid delegate message."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"syntheticLockup")," is used to index bond holders and tracking their\naddresses for reward distribution or potentially slashing purposes.\nThese track whether if your Superfluid stake is currently bonding or\nunbonding."),(0,l.kt)("li",{parentName:"ul"},"An ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," is mostly used for the actual reward\ndistribution or slashing events, and are responsible for\nestablishing the connection between each superfluid staked lock and\ntheir delegation to the validator. These work by transferring the\nsuperfluid OSMO to their respective delegators. Rewards are linearly\nscaled based on how much you have locked for a given (validator,\ndenom) pair. Rewards are first moved to the incentive gauges, then\ndistributed from the gauges. In this way, we're using the existing\ngauge reward system for paying out superfluid staking rewards and\ntracking the amount you have superfluidly staked using the lockup\nmodule."),(0,l.kt)("li",{parentName:"ul"},"Rewards are distributed per epoch, which is currently a day.\n",(0,l.kt)("inlineCode",{parentName:"li"},"abci.go")," checks whether or not the current block is at the\nbeginning of the epoch using ",(0,l.kt)("inlineCode",{parentName:"li"},"BeginBlock"),"."),(0,l.kt)("li",{parentName:"ul"},"Superfluid staking will continue to expand to other Osmosis pools\nbased on governance proposals and vote turnouts.")),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)("p",null,"If Alice has 500 GAMM tokens bonded to the ATOM \\<",">"," OSMO, she will have\nthe equivalent value of OSMO minted, delegated to her chosen staker, and\nburned for her each day with Superfluid staking. On the user side, all\nshe has to know is who she wants to delegate her tokens to. In order to\nswitch delegation, she has to unbond her tokens from the pool first and\nthen redeposit. Bob, who has a share of the same liquidity pool before\nSuperfluid Staking went live, also has to re-deposit into the pool for\nthe above process to kickstart."),(0,l.kt)("h3",{id:"why-mint-osmo-how-is-this-method-safe-and-accurate"},"Why mint Osmo? How is this method safe and accurate?"),(0,l.kt)("p",null,"Superfluid staking requires the minting of OSMO because in order to\nstake on the Osmosis chain, OSMO tokens are required as the chosen\ncollateral. Synthetic Osmo is minted here as a representative of the\nvalue of each superfluid staker's liquidity pool tokens."),(0,l.kt)("p",null,"The pool tokens are acquired by the user from normally staking in a\nliquidity pool. They get minted an amount of OSMO equivalent to the\nvalue of their GAMM pool tokens. This method is accurate because\nquerying the value OSMO every day allows for burning and minting\naccording to the difference in value of OSMO relative to the expected\ndelegation amount (as seen with\n",(0,l.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/main/x/superfluid/keeper/stake.go"},"GetExpectedDelegationAmount"),").\nIt's like having a price oracle for fairly calculating the amount the\nuser has superfluidly staked."),(0,l.kt)("p",null,'On epoch (start of every day), we read from the lockup module how much\nGAMM tokens we have locked which acts as an oracle for the\nrepresentative price of the GAMM token shares. The superfluid module has\n"hooks" messages to refresh delegation amounts\n(',(0,l.kt)("inlineCode",{parentName:"p"},"RefreshIntermediaryDelegationAmounts"),") and to increase delegation on\nlockup (",(0,l.kt)("inlineCode",{parentName:"p"},"IncreaseSuperfluidDelegation"),"). Then, we see whether or not the\nsuperfluid OSMO currently delegated is worth more or less than this\nexpected delegation amount. If the OSMO is worth more, we do\ninstant undelegations and immediately burn the OSMO. If less, we mint\nOSMO and update the amount delegated. A simplified diagram of this whole\nprocess is found below:"),(0,l.kt)("img",{src:"https://raw.githubusercontent.com/osmosis-labs/osmosis/main/x/superfluid/superfluiddiagram.png",height:"300"}),(0,l.kt)("p",null,"This minting is safe because we strict constrain the permissions of Bank\n(the module that burns and mints OSMO) to do what it's designed to do.\nThe authority is mediated through ",(0,l.kt)("inlineCode",{parentName:"p"},"mintOsmoTokensAndDelegate")," and\n",(0,l.kt)("inlineCode",{parentName:"p"},"forceUndelegateAndBurnOsmoTokens")," keeper methods called by the\n",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidDelegate")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidUndelegate")," message handlers for the\ntokens. The hooks above that increase delegation and refresh delegation\namounts also call this keeper method."),(0,l.kt)("p",null,"The delegation is then verified to not already be associated with an\nintermediary account (to prevent double-staking), and is always\ndelegated or withdrawn taking into account various multipliers for\nsynthetic OSMO value (its worth with respect to the liquidity pool, and\na risk modifier) to prevent mint inaccuracies. Before minting, we also\ncheck that the message sender is the owner of the locked funds; that the\nlock is not unlocking; is locked for at least the unbonding period, and\nis bonded to a single asset. We also check to see if the lock isn't\nalready in superfluid and that the same lock isn't currently being\nunbonded."),(0,l.kt)("p",null,"On the end of each epoch, we iterate through all intermediary accounts\nto withdraw delegation rewards they may have received and put it all\ninto the perpetual gauges corresponding to each account for reward\ndelegation."),(0,l.kt)("h3",{id:"bonding-unbonding-slashing"},"Bonding, unbonding, slashing"),(0,l.kt)("p",null,"Here, we describe how token bonding and unbonding works, and what\nhappens to your superfluid tokens in the case of a slashing event."),(0,l.kt)("h3",{id:"bonding"},"Bonding"),(0,l.kt)("p",null,"When bonding, your input tokens are locked up and you are given GAMM\npool tokens in exchange. These GAMM pool tokens represent a share of the\ntotal liquidity pool, and allows you to get transaction fees or\nparticipate in external incentive gauge token distributions. When\nbonding, on top of the regular bonding transaction there will also be a\nselection of validators. As stated above, OSMO is also minted and burned\neach day and superfluidly staked to whoever you have chosen to be your\nvalidator. You gain additional APR as a reward for bolstering the\nOsmosis chain's consensus integrity by delegating."),(0,l.kt)("h3",{id:"unbonding"},"Unbonding"),(0,l.kt)("p",null,"When unbonding, superfluid tokens get un-delegated. After making sure\nthat the unbond message sender is the owner of their corresponding\nlocked funds, the existing synthetic lockup is deleted and replaced with\na new synthetic lockup for unbonding purposes. The undelegated OSMO is\nthen instantly withdrawn from the intermediate account and validator\nusing the InstantUndelegate function. The OSMO that was originally used\nfor representing your LP shares are burnt. Moves the tracker for\nunbonding, allows the underlying lock to start unlocking if desired"),(0,l.kt)("h2",{id:"concepts"},"Concepts"),(0,l.kt)("h3",{id:"syntheticlockups"},"SyntheticLockups"),(0,l.kt)("p",null,"SyntheticLockups are synthetic forms of PeriodLocks, but different in the\nsense that they store suffix, which is a combination of\nbonding/unbonding status + validator address. This is mainly used to\ntrack whether an individual lock that has been superfluid staked has an\nbonding status or an unbonding status from the staking delegations."),(0,l.kt)("h3",{id:"intermediary-account"},"Intermediary Account"),(0,l.kt)("p",null,"Intermediary Accounts establish the connections between the superfluid\nstaked locks and delegations to the validator. Intermediary accounts\nexist for every denom + validator combination, so that it would group\nlocks with the same denom + validator selection. Superfluid staking a\nlock would mint equivalent amount of OSMO of the lock and send it to the\nintermediary account and the intermediary accounts would be delegating\nto the specified validator."),(0,l.kt)("h3",{id:"intermediary-account-connection"},"Intermediary Account Connection"),(0,l.kt)("p",null,"Intermediary Accounts Connection serves the role of tracking the locks\nthat an Intermediary Account is dedicated to."),(0,l.kt)("h2",{id:"state"},"State"),(0,l.kt)("h3",{id:"superfluid-asset"},"Superfluid Asset"),(0,l.kt)("p",null,"A superfluid asset is an alternative asset (non-OSMO) that is allowed by\ngovernance to be used for staking."),(0,l.kt)("p",null,"It can only be updated by governance proposals. We validate at proposal\ncreation time that the denom + pool exists. (Are we going to ignore edge\ncases around a reference pool getting deleted it)"),(0,l.kt)("h3",{id:"intermediary-accounts"},"Intermediary Accounts"),(0,l.kt)("p",null,"Lots of questions to be answered here"),(0,l.kt)("h3",{id:"dedicated-gauges"},"Dedicated Gauges"),(0,l.kt)("p",null,"Each intermediary account has a dedicated gauge where it sends the\ndelegation rewards to. Gauges are distributing the rewards to end users\nat the end of the epoch."),(0,l.kt)("h3",{id:"synthetic-lockups-created"},"Synthetic Lockups created"),(0,l.kt)("p",null,"At the moment, one lock can only be fully bonded to one validator."),(0,l.kt)("h3",{id:"osmo-equivalent-multipliers"},"Osmo Equivalent Multipliers"),(0,l.kt)("p",null,"The Osmo Equivalent Multiplier for an asset is the multiplier it has for\nits value relative to OSMO."),(0,l.kt)("p",null,"Different types of assets can have different functions for calculating\ntheir multiplier. We currently support two asset types."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Native Token")),(0,l.kt)("p",null,"The multiplier for OSMO is always 1."),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"Gamm LP Shares")),(0,l.kt)("p",null,"Currently we use the spot price for an asset based on a designated\nosmo-basepair pool of an asset. The multiplier is set once per epoch, at\nthe beginning of the epoch. In the future, we will switch this out to\nuse a TWAP instead."),(0,l.kt)("h3",{id:"state-changes"},"State changes"),(0,l.kt)("p",null,"The state of superfluid module state modifiers are classified into below\ncategories."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#proposals"},"Proposals")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#messages"},"Messages")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#epochs"},"Epoch")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#superfluid-hooks"},"Hooks"))),(0,l.kt)("h1",{id:"messages"},"Messages"),(0,l.kt)("h3",{id:"superfluid-delegate"},"Superfluid Delegate"),(0,l.kt)("p",null,"Owners of superfluid asset locks can submit ",(0,l.kt)("inlineCode",{parentName:"p"},"MsgSuperfluidDelegate"),"\ntransactions to delegate the Osmo in their locks to a selected\nvalidator."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.go}"},"type MsgSuperfluidDelegate struct {\n Sender  string\n LockId  uint64\n ValAddr string\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"State Modifications:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Safety Checks that are being done before running superfluid logic:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Check that ",(0,l.kt)("inlineCode",{parentName:"li"},"Sender")," is the owner of ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")),(0,l.kt)("li",{parentName:"ul"},"Check that ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")," corresponds to a single locked asset"),(0,l.kt)("li",{parentName:"ul"},"Check that ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")," is not unlocking"),(0,l.kt)("li",{parentName:"ul"},"Check that ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")," is locked for at least the unbonding period"),(0,l.kt)("li",{parentName:"ul"},"Check that this ",(0,l.kt)("inlineCode",{parentName:"li"},"LockID")," is not already superfluided"),(0,l.kt)("li",{parentName:"ul"},"Check that the same lock isn't being unbonded"))),(0,l.kt)("li",{parentName:"ul"},"Get the ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," for this lock's ",(0,l.kt)("inlineCode",{parentName:"li"},"Denom")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"ValAddr"),"\npair.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Create it + a new gauge for the synthetic denom, if it does not\nyet exist."))),(0,l.kt)("li",{parentName:"ul"},"Create a SyntheticLockup."),(0,l.kt)("li",{parentName:"ul"},"Calculate ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," to delegate on behalf of this ",(0,l.kt)("inlineCode",{parentName:"li"},"lock"),", as\n",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo Equivalent Multiplier")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"li"},"# LP Shares")," ","*",(0,l.kt)("inlineCode",{parentName:"li"},"Risk Adjustment Factor"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"If this amount is less than 0.000001 ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," (",(0,l.kt)("inlineCode",{parentName:"li"},"1 uosmo"),") reject\nthe transaction, as it would be delegating ",(0,l.kt)("inlineCode",{parentName:"li"},"0 uosmo")))),(0,l.kt)("li",{parentName:"ul"},"Mint ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," to match this amount and send to ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")),(0,l.kt)("li",{parentName:"ul"},"Create a delegation from ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"Validator")),(0,l.kt)("li",{parentName:"ul"},"Create a new perpetual ",(0,l.kt)("inlineCode",{parentName:"li"},"Gauge")," for distributing staking payouts to\nlocks of a synethic asset based on this ",(0,l.kt)("inlineCode",{parentName:"li"},"Validator")," / ",(0,l.kt)("inlineCode",{parentName:"li"},"Denom")," pair."),(0,l.kt)("li",{parentName:"ul"},"Create a connection between this ",(0,l.kt)("inlineCode",{parentName:"li"},"lockID")," and this\n",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount"))),(0,l.kt)("h3",{id:"superfluid-undelegate"},"Superfluid Undelegate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.go}"},"type MsgSuperfluidUndelegate struct {\n Sender string\n LockId uint64\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"State Modifications:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Lookup ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")," by ",(0,l.kt)("inlineCode",{parentName:"li"},"LockID")),(0,l.kt)("li",{parentName:"ul"},"Check that ",(0,l.kt)("inlineCode",{parentName:"li"},"Sender")," is the owner of ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")),(0,l.kt)("li",{parentName:"ul"},"Get the ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," for this ",(0,l.kt)("inlineCode",{parentName:"li"},"lockID")),(0,l.kt)("li",{parentName:"ul"},"Delete the ",(0,l.kt)("inlineCode",{parentName:"li"},"SyntheticLockup")," associated to this ",(0,l.kt)("inlineCode",{parentName:"li"},"lockID")," + ",(0,l.kt)("inlineCode",{parentName:"li"},"ValAddr"),"\npair"),(0,l.kt)("li",{parentName:"ul"},"Create a new ",(0,l.kt)("inlineCode",{parentName:"li"},"SyntheticLockup")," which is unbonding"),(0,l.kt)("li",{parentName:"ul"},"Calculate the amount of ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," delegated on behalf of this ",(0,l.kt)("inlineCode",{parentName:"li"},"lock")," as\n",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo Equivalent Multiplier")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"li"},"# LP Shares")," ","*",(0,l.kt)("inlineCode",{parentName:"li"},"Risk Adjustment Factor"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"If this amount is less than 0.000001 ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo"),", there is no\ndelegated ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," to undelegate and burn"))),(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("inlineCode",{parentName:"li"},"InstantUndelegate")," to instantly remove delegation from\n",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"Validator")),(0,l.kt)("li",{parentName:"ul"},"Immediately burn undelegated ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")),(0,l.kt)("li",{parentName:"ul"},"Delete the connection between ",(0,l.kt)("inlineCode",{parentName:"li"},"lockID")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount"))),(0,l.kt)("h3",{id:"lock-and-superfluid-delegate"},"Lock and Superfluid Delegate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.go}"},"type MsgLockAndSuperfluidDelegate struct {\n Sender string\n Coins sdk.Coins\n ValAddr string\n}\n")),(0,l.kt)("p",null,"This is effectively a multimsg tx of lockup's ",(0,l.kt)("inlineCode",{parentName:"p"},"MsgLockTokens")," and\nsuperfluid's ",(0,l.kt)("inlineCode",{parentName:"p"},"MsgSuperfluidDelegate"),", but it is implemented as a single\nmsg, because currently we don't have a way of passing the lockid\noutputted by ",(0,l.kt)("inlineCode",{parentName:"p"},"MsgLockTokens")," as an input into the\n",(0,l.kt)("inlineCode",{parentName:"p"},"MsgSuperfluidDelegate")," prior to execution."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"State Modifications:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Ensures that Coins has a length of only 1 (we use sdk.Coins instead\nof sdk.Coin in order to allow more flexibility in the future)"),(0,l.kt)("li",{parentName:"ul"},"Creates a lockup with Coins of a lock duration equivalent to the\nunstaking period from the staking module",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Uses the lockup module's MsgServer"))),(0,l.kt)("li",{parentName:"ul"},"Gets the lock id of the created lock, and uses it generate and\nexecute a MsgSuperfluidDelegate message",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Uses the SuperfluidDelegate function on this msg server")))),(0,l.kt)("h3",{id:"superfluid-unbond-lock"},"Superfluid Unbond Lock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.go}"},"type MsgSuperfluidUnbondLock struct {\n Sender string\n LockId uint64\n}\n")),(0,l.kt)("p",null,"This message does all the functionality of ",(0,l.kt)("inlineCode",{parentName:"p"},"MsgSuperfluidUndelegate")," but\nalso starts unbonding the underlying lock as well, allowing both the\nunstaking and unlocking to complete at the same time. Without using this\nfunction, a user will not be able to start unbonding their underlying\nlock until after the unstaking has finished."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"State Modifications:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"This runs the functionality of ",(0,l.kt)("inlineCode",{parentName:"li"},"MsgSuperfluidUndelegate")),(0,l.kt)("li",{parentName:"ul"},"It then triggers a force unbond of the underlying lock id")),(0,l.kt)("h2",{id:"epochs"},"Epochs"),(0,l.kt)("p",null,"Overall Epoch sequence"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Epoch N ends, during AfterEpochEnd:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Distribute gauge rewards for all non-superfluid gauges"),(0,l.kt)("li",{parentName:"ul"},"Mint new tokens",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Issue new Osmo, and send to various modules (distribution,\nincentives, etc.)"),(0,l.kt)("li",{parentName:"ul"},"25% currently goes to ",(0,l.kt)("inlineCode",{parentName:"li"},"x/distribution")," which funds ",(0,l.kt)("inlineCode",{parentName:"li"},"Staking"),"\nand ",(0,l.kt)("inlineCode",{parentName:"li"},"Superfluid")," rewards"),(0,l.kt)("li",{parentName:"ul"},"Rewards for ",(0,l.kt)("inlineCode",{parentName:"li"},"Superfluid")," are based on the just updated\ndelegation amounts, and queued for payout in the next epoch"))))),(0,l.kt)("li",{parentName:"ul"},"BeginBlock for Distribution",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Distribute staking rewards to all of the 'lazy accounting'\naccumulators. (F1)"))),(0,l.kt)("li",{parentName:"ul"},"Epoch N ends, during BeginBlock for superfluid ",(0,l.kt)("strong",{parentName:"li"},"After"),"\nAfterEpochEnd:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Claim staking rewards for every ",(0,l.kt)("inlineCode",{parentName:"li"},"Intermediary Account"),", put them\ninto gauges."),(0,l.kt)("li",{parentName:"ul"},"Distribute Superfluid staking rewards from gauges to bonded\nSynthetic Lock owners"),(0,l.kt)("li",{parentName:"ul"},"Update ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo Equivalent Multiplier")," value for each LP token",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"(Currently spot price at epoch)"))),(0,l.kt)("li",{parentName:"ul"},"Refresh delegation amounts for all ",(0,l.kt)("inlineCode",{parentName:"li"},"Intermediary Accounts"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Calculate the expected delegation for this account as\n",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo Equivalent Multiplier")," ",(0,l.kt)("em",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"em"},"# LP Shares")),(0,l.kt)("inlineCode",{parentName:"li"},"Risk adjustment"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"If this is less than 0.000001 ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," it will be rounded\nto 0"))),(0,l.kt)("li",{parentName:"ul"},"Lookup current delegation amount for ",(0,l.kt)("inlineCode",{parentName:"li"},"Intermediary Account"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"If there is no delegation, treat the current delegation\nas 0"))),(0,l.kt)("li",{parentName:"ul"},"If expected amount ",">"," current delegation:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Mint new ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Delegate")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"Validator")))),(0,l.kt)("li",{parentName:"ul"},"If expected amount \\< current delegation:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Use ",(0,l.kt)("inlineCode",{parentName:"li"},"InstantUndelegate")," and burn the received ",(0,l.kt)("inlineCode",{parentName:"li"},"Osmo"))))))))),(0,l.kt)("h2",{id:"staking-power-updates"},"Staking power updates"),(0,l.kt)("p",null,"We need to be concerned with how/when validators enter and leave the\nactive set."),(0,l.kt)("p",null,"We expect the guarantee that there is an Intermediary account for every\n(active validator, superfluid denom) pair, and every (unbonding\nvalidator, superfluid denom) pair. (TODO: Where/why)"),(0,l.kt)("p",null,"We also want to avoid resource exhaustion attacks. We relegate concerns\naround upper-bounding the number of active + unbonding validators to the\nstaking module. This module is liable to potentially cause a 100-1000x\namplification factor on this workload."),(0,l.kt)("h3",{id:"how-we-handle-it-now"},"How we handle it now"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Intermediary accounts are not created on SetSuperfluidAsset"),(0,l.kt)("li",{parentName:"ul"},"They are created at-time-of-need on MsgSuperfluidDelegate"),(0,l.kt)("li",{parentName:"ul"},"Concerns: What happens if you delegate to an unbonding or jailed\nvalidator. Note: Isn't it same as normal delegation for unbonding\nvalidator?")),(0,l.kt)("h2",{id:"other-module-hooks"},"Other Module Hooks"),(0,l.kt)("p",null,"-----;"),(0,l.kt)("p",null,'In this section we describe the "hooks" that ',(0,l.kt)("inlineCode",{parentName:"p"},"superfluid")," module\nreceives from other modules."),(0,l.kt)("h3",{id:"afterepochend"},"AfterEpochEnd"),(0,l.kt)("p",null,"On AfterEpochEnd, we iterate through all existing intermediary accounts\nand withdraw delegation rewards they have received. Then we send the\ncollective rewards to the perpetual gauge corresponding to the\nintermediary account. Then we update OSMO backing per share for the\nspecific pool. After the update, iteration through all intermediate\naccounts happen, undelegating and bonding existing delegations for all\nsuperfluid staking and use the updated spot price at epoch time to mint\nand delegate."),(0,l.kt)("h3",{id:"afteraddtokenstolock"},"AfterAddTokensToLock"),(0,l.kt)("p",null,"When a token is locked, we first check if the corresponding lock is\ncurrently in the state of superfluid delegation. If it is, we run the\nlogic to add delegation via intermediary account."),(0,l.kt)("h3",{id:"beforevalidatorslashed"},"BeforeValidatorSlashed"),(0,l.kt)("p",null,"Slashes the synthetic lockups and native lockups that is connected to\nthe to be slashed validator."),(0,l.kt)("h2",{id:"proposal-hooks"},"Proposal Hooks"),(0,l.kt)("p",null,"-----;"),(0,l.kt)("p",null,"In this section we describe the proposals that is associated to\nsuperfluid module."),(0,l.kt)("h3",{id:"setsuperfluidassetsproposal"},"SetSuperfluidAssetsProposal"),(0,l.kt)("p",null,"Enable multiple superfluid assets to be used for superfluid staking."),(0,l.kt)("h3",{id:"removesuperfluidassetsproposal"},"RemoveSuperfluidAssetsProposal"),(0,l.kt)("p",null,"Disable multiple assets from being used for superfluid staking."),(0,l.kt)("h2",{id:"events"},"Events"),(0,l.kt)("p",null,"There are 7 types of events that exist in Superfluid module:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtSetSuperfluidAsset"),' - "set_superfluid_asset"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtRemoveSuperfluidAsset"),' - "remove_superfluid_asset"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtSuperfluidDelegate"),' - "superfluid_delegate"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtSuperfluidIncreaseDelegation"),' - "superfluid_increase_delegation"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtSuperfluidUndelegate"),' - "superfluid_undelegate"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtSuperfluidUnbondLock"),' - "superfluid_unbond_lock"'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.TypeEvtUnpoolId"),' - "unpool_pool_id"')),(0,l.kt)("h3",{id:"typestypeevtsetsuperfluidasset"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtSetSuperfluidAsset")),(0,l.kt)("p",null,"This event is emitted in the proposal which set new superfluid asset"),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeDenom"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the asset denom."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeSuperfluidAssetType"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the type of asset.")))),(0,l.kt)("h3",{id:"typestypeevtremovesuperfluidasset"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtRemoveSuperfluidAsset")),(0,l.kt)("p",null,"This event is emitted in the proposal which removes the superfluid asset"),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeDenom"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the asset denom.")))),(0,l.kt)("h3",{id:"typestypeevtsuperfluiddelegate"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtSuperfluidDelegate")),(0,l.kt)("p",null,"This event is emitted in the message server after successfully creating a delegation for the given lock ID and the validator to delegate to."),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeLockId"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the given lock ID."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeValidator"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the validator address to delegate to.")))),(0,l.kt)("h3",{id:"typestypeevtsuperfluidincreasedelegation"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtSuperfluidIncreaseDelegation")),(0,l.kt)("p",null,"This event is emitted in the hook after adding more token to the existing lock"),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeLockId"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the given lock ID."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeAmount"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the token amount added to the lock.")))),(0,l.kt)("h3",{id:"typestypeevtsuperfluidundelegate"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtSuperfluidUndelegate")),(0,l.kt)("p",null,"This event is emitted in the message server after undelegating the currently superfluid delegated position given by lock ID."),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeLockId"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the given lock ID.")))),(0,l.kt)("h3",{id:"typestypeevtsuperfluidunbondlock"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtSuperfluidUnbondLock")),(0,l.kt)("p",null,"This event is emitted in the message server after starting unbonding for the currently superfluid undelegating lock."),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeLockId"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the given lock ID.")))),(0,l.kt)("h3",{id:"typestypeevtunpoolid"},(0,l.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtUnpoolId")),(0,l.kt)("p",null,"This event is emitted in the message server ",(0,l.kt)("inlineCode",{parentName:"p"},"UnPoolWhitelistedPool")),(0,l.kt)("p",null,"It consists of the following attributes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeKeySender"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the msg sender address."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeLockId"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the pool lpShareDenom."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"types.AttributeNewLockIds"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The value is the exited lock ids in byte[].")))),(0,l.kt)("h3",{id:"messages-1"},"Messages"),(0,l.kt)("h3",{id:"msgsuperfluiddelegate"},"MsgSuperfluidDelegate"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_delegate"),(0,l.kt)("td",{parentName:"tr",align:null},"lock_id"),(0,l.kt)("td",{parentName:"tr",align:null},"{lock_id}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_delegate"),(0,l.kt)("td",{parentName:"tr",align:null},"validator"),(0,l.kt)("td",{parentName:"tr",align:null},"{validator}")))),(0,l.kt)("h3",{id:"msgsuperfluidundelegate"},"MsgSuperfluidUndelegate"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_undelegate"),(0,l.kt)("td",{parentName:"tr",align:null},"lock_id"),(0,l.kt)("td",{parentName:"tr",align:null},"{lock_id}")))),(0,l.kt)("h3",{id:"msgsuperfluidunbondlock"},"MsgSuperfluidUnbondLock"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_unbond_lock"),(0,l.kt)("td",{parentName:"tr",align:null},"lock_id"),(0,l.kt)("td",{parentName:"tr",align:null},"{lock_id}")))),(0,l.kt)("h3",{id:"msglockandsuperfluiddelegate"},"MsgLockAndSuperfluidDelegate"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"period_lock_id"),(0,l.kt)("td",{parentName:"tr",align:null},"{periodLockID}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"owner"),(0,l.kt)("td",{parentName:"tr",align:null},"{owner}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"amount"),(0,l.kt)("td",{parentName:"tr",align:null},"{amount}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"duration"),(0,l.kt)("td",{parentName:"tr",align:null},"{duration}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"unlock_time"),(0,l.kt)("td",{parentName:"tr",align:null},"{unlockTime}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"message"),(0,l.kt)("td",{parentName:"tr",align:null},"action"),(0,l.kt)("td",{parentName:"tr",align:null},"lock_tokens")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"message"),(0,l.kt)("td",{parentName:"tr",align:null},"sender"),(0,l.kt)("td",{parentName:"tr",align:null},"{owner}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"transfer"),(0,l.kt)("td",{parentName:"tr",align:null},"recipient"),(0,l.kt)("td",{parentName:"tr",align:null},"{moduleAccount}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"transfer"),(0,l.kt)("td",{parentName:"tr",align:null},"sender"),(0,l.kt)("td",{parentName:"tr",align:null},"{owner}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"transfer"),(0,l.kt)("td",{parentName:"tr",align:null},"amount"),(0,l.kt)("td",{parentName:"tr",align:null},"{amount}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_delegate"),(0,l.kt)("td",{parentName:"tr",align:null},"lock_id"),(0,l.kt)("td",{parentName:"tr",align:null},"{lock_id}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_delegate"),(0,l.kt)("td",{parentName:"tr",align:null},"validator"),(0,l.kt)("td",{parentName:"tr",align:null},"{validator}")))),(0,l.kt)("h2",{id:"proposals"},"Proposals"),(0,l.kt)("h3",{id:"setsuperfluidassetsproposal-1"},"SetSuperfluidAssetsProposal"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"set_superfluid_asset"),(0,l.kt)("td",{parentName:"tr",align:null},"denom"),(0,l.kt)("td",{parentName:"tr",align:null},"{denom}")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"set_superfluid_asset"),(0,l.kt)("td",{parentName:"tr",align:null},"superfluid_asset_type"),(0,l.kt)("td",{parentName:"tr",align:null},"{asset_type}")))),(0,l.kt)("h3",{id:"removesuperfluidassetsproposal-1"},"RemoveSuperfluidAssetsProposal"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Attribute Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"remove_superfluid_asset"),(0,l.kt)("td",{parentName:"tr",align:null},"denom"),(0,l.kt)("td",{parentName:"tr",align:null},"{denom}")))),(0,l.kt)("h2",{id:"queries"},"Queries"),(0,l.kt)("h3",{id:"params"},"Params"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-protobuf"},"message ParamsRequest {};\n\nmessage ParamsResponse {\n  // params defines the parameters of the module.\n  Params params = 1 [ (gogoproto.nullable) = false ];\n}\n\nmessage Params {\n  sdk.Dec minimum_risk_factor = 1; // serialized as string\n}\n")),(0,l.kt)("p",null,"The params query returns the params for the superfluid module. This\ncurrently contains:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"MinimumRiskFactor")," which is an sdk.Dec that represents the discount\nto apply to all superfluid staked modules when calculating their\nstaking power. For example, if a specific denom has an OSMO\nequivalent value of 100 OSMO, but the ",(0,l.kt)("inlineCode",{parentName:"li"},"MinimumRiskFactor")," param\nis 0.05, then the denom will only get 95 OSMO worth of staking power\nwhen staked.")),(0,l.kt)("h3",{id:"assettype"},"AssetType"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-protobuf"},"message AssetTypeRequest {\n    string denom = 1;\n};\n\nmessage AssetTypeResponse {\n    SuperfluidAssetType asset_type = 1;\n};\n\nenum SuperfluidAssetType {\n  SuperfluidAssetTypeNative = 0;\n  SuperfluidAssetTypeLPShare = 1;\n}\n")),(0,l.kt)("p",null,'The AssetType query returns what type of superfluid asset a denom is.\nAssetTypes are meant for when we support more types of assets for\nsuperfluid staking than just LP shares. Each AssetType has a different\nalgorithm used to get its "Osmo equivalent value".'),(0,l.kt)("p",null,"We represent different types of superfluid assets as different enums.\nCurrently, only enum ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," is actually used. Enum value ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," is reserved\nfor the Native staking token for if we deprecate the legacy staking\nworkflow to have native staking also go through the superfluid module.\nIn the future, more enums will be added."),(0,l.kt)("p",null,"If this query errors, that means that a denom is not allowed to be used\nfor superfluid staking."),(0,l.kt)("h3",{id:"allassets"},"AllAssets"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-protobuf"},"message AllAssetsRequest {};\n\nmessage AllAssetsResponse {\n  repeated SuperfluidAsset assets = 1 [ (gogoproto.nullable) = false ];\n};\n\nmessage SuperfluidAsset {\n  string denom = 1;\n  SuperfluidAssetType asset_type = 2;\n}\n")),(0,l.kt)("p",null,"This parameterless query returns a list of all the superfluid staking\ncompatible assets. The return value includes a list of SuperfluidAssets,\nwhich are pairs of ",(0,l.kt)("inlineCode",{parentName:"p"},"denom")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidAssetType")," which was\ndescribed in the previous section."),(0,l.kt)("p",null,"This query does not currently support pagination, but may in the future."),(0,l.kt)("h3",{id:"assetmultiplier"},"AssetMultiplier"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-protobuf"},"message AssetMultiplierRequest {\n    string denom = 1;\n};\n\nmessage AssetMultiplierResponse {\n  OsmoEquivalentMultiplierRecord osmo_equivalent_multiplier = 1;\n};\n\nmessage OsmoEquivalentMultiplierRecord {\n  int64 epoch_number = 1;\n  string denom = 2;\n  string multiplier = 3;\n}\n")),(0,l.kt)("p",null,"This query allows you to find the multiplier factor on a specific denom.\nThe Osmo-Equivalent-Multiplier Record for epoch N refers to the osmo\nworth we treat a denom as having, for all of epoch N. For now, this is\nthe spot price at the last epoch boundary, and this is reset every\nepoch. We currently don't store historical multipliers, so the epoch\nparameter is kind of meaningless for now."),(0,l.kt)("p",null,"To calculate the staking power of the denom, one needs to multiply the\namount of the denom with ",(0,l.kt)("inlineCode",{parentName:"p"},"OsmoEquivalentMultipler")," from this query with\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"MinimumRiskFactor")," from the Params query endpoint."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"staking_power = amount * OsmoEquivalentMultipler * MinimumRiskFactor")),(0,l.kt)("h3",{id:"connectedintermediaryaccount"},"ConnectedIntermediaryAccount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-protobuf"},"message ConnectedIntermediaryAccountRequest {\n  uint64 lock_id = 1;\n}\n\nmessage ConnectedIntermediaryAccountResponse {\n  SuperfluidIntermediaryAccountInfo account = 1;\n}\n\nmessage SuperfluidIntermediaryAccount {\n  string denom = 1;\n  string val_addr = 2;\n  uint64 gauge_id = 3; // perpetual gauge for rewards distribution\n}\n")),(0,l.kt)("p",null,'Every superfluid denom and validator pair has an associated\n"intermediary account", which does the actual delegation. This query\nhelps find the superfluid intermediary account for any superfluid\nposition.'),(0,l.kt)("p",null,"That ",(0,l.kt)("inlineCode",{parentName:"p"},"lock_id")," parameter passed in is the underlying lock id for the\nsuperfluid, NOT the synthetic lock id."),(0,l.kt)("p",null,"This query can be used to find the validator a superfluid lock is\ndelegated to. The ",(0,l.kt)("inlineCode",{parentName:"p"},"gauge_id")," also refers to the perpetual gauge that is\nused to pay out the superfluid positions associated with this\nintermediary account."),(0,l.kt)("h3",{id:"allintermediaryaccounts"},"AllIntermediaryAccounts"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.protobuf}"},"message AllIntermediaryAccountsRequest {\n  cosmos.base.query.v1beta1.PageRequest pagination = 1;\n};\n\nmessage AllIntermediaryAccountsResponse {\n  repeated SuperfluidIntermediaryAccountInfo accounts = 1;\n  cosmos.base.query.v1beta1.PageResponse pagination = 2;\n};\n")),(0,l.kt)("p",null,"This query returns a list of all superfluid intermediary accounts. It\nsupports pagination."),(0,l.kt)("h3",{id:"superfluiddelegationamount"},"SuperfluidDelegationAmount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.protobuf}"},"message SuperfluidDelegationAmountRequest {\n  string delegator_address = 1;\n  string validator_address = 2;\n  string denom = 3;\n}\n\nmessage SuperfluidDelegationAmountResponse {\n  repeated cosmos.base.v1beta1.Coin amount = 1 [];\n}\n")),(0,l.kt)("p",null,"This query returns the amount of underlying denom (i.e. lp share) for a\ntriplet of delegator, validator, and denom."),(0,l.kt)("h3",{id:"superfluiddelegationsbydelegator"},"SuperfluidDelegationsByDelegator"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.protobuf}"},"message SuperfluidDelegationsByDelegatorRequest {\n  string delegator_address = 1;\n}\n\nmessage SuperfluidDelegationsByDelegatorResponse {\n  repeated SuperfluidDelegationRecord superfluid_delegation_records = 1;\n  repeated cosmos.base.v1beta1.Coin total_delegated_coins = 2;\n}\n\nmessage SuperfluidDelegationRecord {\n  string delegator_address = 1;\n  string validator_address = 2;\n  cosmos.base.v1beta1.Coin delegation_amount = 3;\n}\n")),(0,l.kt)("p",null,"This query returns a list of all the superfluid delegations of a\nspecific delegator. The return value includes, the validator delegated to\nand the delegated coins (both denom and amount)."),(0,l.kt)("p",null,"The return value of the query also includes the ",(0,l.kt)("inlineCode",{parentName:"p"},"total_delegated_coins"),"\nwhich is the sum of all the delegations of that validator."),(0,l.kt)("p",null,"This query does require iteration that is linear with the number of\ndelegations a delegator has made, but for now until we support many\nsuperfluid denoms, should be relatively bounded. Once that increases, we\nwill need to support pagination."),(0,l.kt)("h3",{id:"superfluiddelegationsbyvalidatordenom"},"SuperfluidDelegationsByValidatorDenom"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.protobuf}"},"message SuperfluidDelegationsByValidatorDenomRequest {\n  string validator_address = 1;\n  string denom = 2;\n}\n\nmessage SuperfluidDelegationsByValidatorDenomResponse {\n  repeated SuperfluidDelegationRecord superfluid_delegation_records = 1;\n}\n")),(0,l.kt)("p",null,"This query returns a list of all superfluid delegations that are with a\nvalidator / superfluid denom pair. This query requires a lot of\niteration and should be used sparingly. We will need to add pagination\nto make this usable."),(0,l.kt)("h3",{id:"estimatesuperfluiddelegatedamountbyvalidatordenom"},"EstimateSuperfluidDelegatedAmountByValidatorDenom"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-{.protobuf}"},"message EstimateSuperfluidDelegatedAmountByValidatorDenomRequest {\n  string validator_address = 1;\n  string denom = 2;\n}\n\nmessage EstimateSuperfluidDelegatedAmountByValidatorDenomResponse {\n  repeated cosmos.base.v1beta1.Coin total_delegated_coins = 1;\n}\n")),(0,l.kt)("p",null,"This query returns the total amount of delegated coins for a validator /\nsuperfluid denom pair. This query does NOT involve iteration, so should\nbe used instead of the above ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidDelegationsByValidatorDenom"),'\nwhenever possible. It is called an "Estimate" because it can have some\nslight rounding errors, due to conversions between sdk.Dec and\nsdk.Int\\", but for the most part it should be very close to the sum of\nthe results of the previous query.'),(0,l.kt)("h2",{id:"parameters"},"Parameters"),(0,l.kt)("p",null,"The superfluid module contains the following parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Key"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Example"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"minimum_risk_factor"),(0,l.kt)("td",{parentName:"tr",align:null},"decimal"),(0,l.kt)("td",{parentName:"tr",align:null},"0.01")))),(0,l.kt)("h2",{id:"slashing"},"Slashing"),(0,l.kt)("p",null,"Slashing works by gathering all accounts who were superfluidly staking\nand delegated to the violating validator and slashing their underlying\nlock collateral. The amount of tokens to slash are first calculated then\nremoved from the underlying and synthetic lock. Therefore, it is\nimportant to select a reputable or reliable validator as to minimize\nslashing risks on your tokens. At the moment we are slashing at latest\nprice rather than block height price. All slashed tokens go to the\ncommunity pool."),(0,l.kt)("p",null,"We first get a hook from the staking module, marking that a validator is\nabout to be slashed at a slashFactor of ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),", for an infraction at height\n",(0,l.kt)("inlineCode",{parentName:"p"},"h"),"."),(0,l.kt)("p",null,"The staking module handles slashing every delegation to that validator,\nwhich will handle slashing the delegation from every intermediary\naccount. However, it is up to the superfluid module to then:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Slash every constituent superfluid staking position for this\nvalidator."),(0,l.kt)("li",{parentName:"ul"},"Slash every unbonding superfluid staking position to this validator.")),(0,l.kt)("p",null,"We do this by:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Collect all intermediate accounts to this validator"),(0,l.kt)("li",{parentName:"ul"},"For each IA, iterate over every lock to the underlying native denom."),(0,l.kt)("li",{parentName:"ul"},"If the lock has a synthetic lockup, it gets slashed."),(0,l.kt)("li",{parentName:"ul"},"The slash works by calculating the amount of tokens to slash."),(0,l.kt)("li",{parentName:"ul"},"It removes these from the underlying lock and the synthetic lock."),(0,l.kt)("li",{parentName:"ul"},"These coins are moved to the community pool.")),(0,l.kt)("h3",{id:"nuances"},"Nuances"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Slashed tokens go to the community pool, rather than being burned as\nin staking."),(0,l.kt)("li",{parentName:"ul"},"We slash every unbonding, rather than just unbondings that started\nafter the infraction height."),(0,l.kt)("li",{parentName:"ul"},'We can "overslash" relative to the staking module. (For a slash\nfactor of 5%, the staking module can often burn \\<5% of active\ndelegation, but superfluid will always slash 5%)')),(0,l.kt)("p",null,"We slash every unbonding, purely because lockup module tracks things by\nunbonding start time, whereas staking/slashing tracks things by height\nwe begin unbonding at. Thus we get a problem that we cannot convert\nbetween these cleanly. Really there should be a storage of all\nhistorical block height \\<",">"," block times for everything in the unbonding\nperiod, but this is not considered a near-term problem."),(0,l.kt)("h3",{id:"correcting-overslashing"},"Correcting overslashing"),(0,l.kt)("p",null,"The overslashing possibility stems from a problem in the SDKs slashing\nmodule, that really is a bug there, and superfluid is doing the correct\nthing. ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/cosmos/cosmos-sdk/issues/1440"},"https://github.com/cosmos/cosmos-sdk/issues/1440")),(0,l.kt)("p",null,"Basically, slashes to unbondings and redelegations can lower the amount\nthat gets slashed from live delegations in the staking module today."),(0,l.kt)("p",null,"It turns out this edge case, where superfluid's intermediate account can\nhave more delegation than expected from its underlying collateral, is\nalready safely handled by the Superfluid refreshing logic."),(0,l.kt)("p",null,"The refreshing logic checks the total amount of tokens in locks to this\ndenom (Reading from the lockup accumulation store), calculates how many\nosmo that's worth at the epochs new osmo worth for that asset, and then\nuses that. Thus this safely handles this edge case, as it uses the new\n'live' lockup amount."),(0,l.kt)("h2",{id:"minting"},"Minting"),(0,l.kt)("p",null,"Superfluid module has the ability to arbitrarily mint and burn Osmo\nthrough the ",(0,l.kt)("inlineCode",{parentName:"p"},"bank")," module. This is potentially dangerous so we strictly\nconstrain it's ability to do so. This authority is mediated through the\n",(0,l.kt)("inlineCode",{parentName:"p"},"mintOsmoTokensAndDelegate")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"forceUndelegateAndBurnOsmoTokens"),"\nkeeper methods, which are in turn called by message handlers\n(",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidDelegate")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidUndelegate"),") as well as by hooks on\nEpoch (",(0,l.kt)("inlineCode",{parentName:"p"},"RefreshIntermediaryDelegationAmounts"),") and Lockup\n(",(0,l.kt)("inlineCode",{parentName:"p"},"IncreaseSuperfluidDelegation"),")"),(0,l.kt)("h3",{id:"invariant"},"Invariant"),(0,l.kt)("p",null,"Each of these mechanisms maintains a local invariant between the amount\nof Osmo minted and delegated by the ",(0,l.kt)("inlineCode",{parentName:"p"},"IntermediaryAccount"),", and the\nquantity of the underlying asset held by locks associated to the\naccount, modified by ",(0,l.kt)("inlineCode",{parentName:"p"},"OsmoEquivalentMultiplier")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"RiskAdjustment")," for\nthe underlying asset. Namely that total minted/delegated =\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetTotalSyntheticAssetsLocked")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"p"},"GetOsmoEquivalentMultiplier")," ","*","\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetRiskAdjustment")),(0,l.kt)("p",null,"This can be equivalently expressed as ",(0,l.kt)("inlineCode",{parentName:"p"},"GetExpectedDelegationAmount"),"\nbeing equal to the actual delegation amount."),(0,l.kt)("h2",{id:"message-handlers"},"Message Handlers"),(0,l.kt)("h3",{id:"superfluiddelegate"},"SuperfluidDelegate"),(0,l.kt)("p",null,"In a ",(0,l.kt)("inlineCode",{parentName:"p"},"SuperfluidDelegate")," transaction, we first verify that this lock is\nnot already associated to an ",(0,l.kt)("inlineCode",{parentName:"p"},"IntermediaryAccount"),", and then use\n",(0,l.kt)("inlineCode",{parentName:"p"},"mintOsmoTokenAndDelegate")," to properly balance the resulting change in\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetExpectedDelegationAmount")," from the increase in\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetTotalSyntheticAssetsLocked"),". i.e. we mint and delegate:\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetOsmoEquivalentMultiplier")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"p"},"GetRiskAdjustment")," ","*","\n",(0,l.kt)("inlineCode",{parentName:"p"},"lock.Coins.Amount")," new Osmo tokens."),(0,l.kt)("h3",{id:"superfluidundelegate"},"SuperfluidUndelegate"),(0,l.kt)("p",null,"When a user submits a transaction to unlock their asset the invariant is\nmaintained by using ",(0,l.kt)("inlineCode",{parentName:"p"},"forceUndelegateAndBurnOsmoTokens")," to remove an\namount of Osmo equal to ",(0,l.kt)("inlineCode",{parentName:"p"},"lockedCoin.Amount")," ","*","\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetOsmoEquivalentMultiplier")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"p"},"GetRiskAdjustment"),"."),(0,l.kt)("h2",{id:"superfluid-hooks"},"Superfluid Hooks"),(0,l.kt)("h3",{id:"refreshintermediarydelegationamounts-afterepochend-hook"},"RefreshIntermediaryDelegationAmounts (AfterEpochEnd Hook)"),(0,l.kt)("p",null,"In the ",(0,l.kt)("inlineCode",{parentName:"p"},"RefreshIntermediaryDelegationAmounts")," method, calls are made to\n",(0,l.kt)("inlineCode",{parentName:"p"},"mintOsmoTokensAndDelegate")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"forceUndelegateAndBurnOsmoTokens")," to\nadjust the real delegation up or down to match\n",(0,l.kt)("inlineCode",{parentName:"p"},"GetExpectedDelegationAmount"),"."),(0,l.kt)("h3",{id:"increasesuperfluiddelegation-afteraddtokenstolock-hook"},"IncreaseSuperfluidDelegation (AfterAddTokensToLock Hook)"),(0,l.kt)("p",null,"This is called as a result of a user adding more assets to a lock that\nhas already been associated to an ",(0,l.kt)("inlineCode",{parentName:"p"},"IntermediaryAccount"),". The invariant\nis maintained by using ",(0,l.kt)("inlineCode",{parentName:"p"},"mintOsmoTokenAndDelegate")," to match the amount of\nnew asset locked ","*"," ",(0,l.kt)("inlineCode",{parentName:"p"},"GetOsmoEquivalentMultiplier")," ","*"," ",(0,l.kt)("inlineCode",{parentName:"p"},"GetRiskAdjustment"),"\nfor the underlying asset."),(0,l.kt)("h3",{id:"slashlockupsforvalidatorslash-beforevalidatorslashed-hook"},"SlashLockupsForValidatorSlash (BeforeValidatorSlashed Hook)"),(0,l.kt)("p",null,"During slashing the invariant is likely to be temporarily broken if the\nreferenced validator has any unbonding delegations. These unbonding\ndelegations are slashed first, which means that the amount delegated by\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"IntermediaryAccount")," will be slashed by less than the\n",(0,l.kt)("inlineCode",{parentName:"p"},"SyntheticLock"),"s held by the account."),(0,l.kt)("h2",{id:"see-also"},"See Also"),(0,l.kt)("h3",{id:"gettotalsyntheticassetslocked"},"GetTotalSyntheticAssetsLocked"),(0,l.kt)("p",null,"TODO - expand on this Uses ",(0,l.kt)("inlineCode",{parentName:"p"},"lockup")," accumulator to find total amount of\nsynthetic locks for a given ",(0,l.kt)("inlineCode",{parentName:"p"},"IntermediaryAccount")," (Superfluid Asset +\nValidator pair)"))}p.isMDXComponent=!0}}]);